{"componentChunkName":"component---src-templates-post-template-tsx","path":"/keeping-components-pure/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"tableOfContents":"<ul>\n<li>\n<p><a href=\"#purity-components-as-formulas\">Purity: Components as formulas</a></p>\n<ul>\n<li><a href=\"#it-minds-its-own-business\">It minds its own business</a></li>\n<li><a href=\"#same-inputs-same-outputs\">Same inputs, same outputs</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#side-effects-unintended-consequence\">Side Effects: (un)intended consequence</a></p>\n</li>\n<li>\n<p><a href=\"#local-mutation-your-components-little-secret\">Local mutation: Your component’s little secret</a></p>\n</li>\n<li>\n<p><a href=\"#where-you-can-cause-side-effects\">Where you can cause side effects</a></p>\n</li>\n<li>\n<p><a href=\"#why-does-react-care-about-purity\">Why does React care about purity?</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%83%88%EB%A1%AD%EA%B2%8C-%EC%95%8C%EA%B2%8C-%EB%90%9C-%EC%A0%90\">새롭게 알게 된 점</a></p>\n</li>\n<li>\n<p><a href=\"#%EC%B0%B8%EA%B3%A0\">참고</a></p>\n</li>\n</ul>","timeToRead":5,"html":"<blockquote>\n<p><strong>- 주의 -</strong> <br /> 정리하면서 저의 생각도 많이 넣는 편입니다. <br /> 혹시나 제 글을 읽으실 때 아리송한 부분이 생기신다면 해당하는 공식 문서를 꼭 참고하시길 바랍니다. <br /> 또한, 저에게 익숙한 내용들은 생략하고 정리합니다.</p>\n</blockquote>\n<p>순수 함수는 주어진 계산만 할 뿐 사이드 이펙트를 발생시키지 않는다. React에서도 컴포넌트를 순수 함수로 엄격히 작성해나가면 코드 사이즈가 커질 수록 발생할 수 있는 예상치 못한 버그와 동작을 방지할 수 있다.</p>\n<h2 id=\"purity-components-as-formulas\" style=\"position:relative;\"><a href=\"#purity-components-as-formulas\" aria-label=\"purity components as formulas permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Purity: Components as formulas</h2>\n<p>컴퓨터 과학에서, 특히 함수형 프로그래밍에서 순수 함수는 다음 특성들을 따른다.</p>\n<h3 id=\"it-minds-its-own-business\" style=\"position:relative;\"><a href=\"#it-minds-its-own-business\" aria-label=\"it minds its own business permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>It minds its own business</h3>\n<p>순수 함수는 순수 함수가 호출 되기 전 존재하던 객체 등의 어떠한 변수도 변경시키지 않는다.</p>\n<h3 id=\"same-inputs-same-outputs\" style=\"position:relative;\"><a href=\"#same-inputs-same-outputs\" aria-label=\"same inputs same outputs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Same inputs, same outputs</h3>\n<p>입력값이 계속해서 동일하게 주어진다면 순수 함수는 출력값도 계속해서 동일하게 반환해야 한다.</p>\n<p>다음 예시를 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">double</span><span class=\"token punctuation\">(</span><span class=\"token builtin\">number</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> <span class=\"token builtin\">number</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위 함수는 number를 받아 2를 곱하고 반환한다. double이라는 함수는 어떠한 다른 변수도 변경시키지 않는다. 그리고 계속해서 input 값, 즉 number가 3으로 주어진다면 계속해서 6을 뱉어낼 것이다. 어떨 땐 6이고 어떨 땐 -1이고 어떨 땐 2.5가 아니라 항상 number로 3이 주어진다면 6을 항상 뱉어낼 것이다. 따라서 double이라는 함수는 순수 함수이다.</p>\n<p>React도 이러한 개념에 맞추어 설계되었다. React는 우리가 작성하는 Component가 항상 순수 함수일 것이라고 가정한다. 이 뜻은 즉, 우리가 작성하는 React Component는 동일한 입력값이 주어진다면 동일한 JSX문을 반환해야 한다는 것이다.</p>\n<h2 id=\"side-effects-unintended-consequence\" style=\"position:relative;\"><a href=\"#side-effects-unintended-consequence\" aria-label=\"side effects unintended consequence permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Side Effects: (un)intended consequence</h2>\n<p>순수성을 깨는 예시를 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">let</span> guest <span class=\"token operator\">=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">Cup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// Bad: changing a preexisting variable!</span>\n  guest <span class=\"token operator\">=</span> guest <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h2</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Tea cup for guest #</span><span class=\"token punctuation\">{</span>guest<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h2</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">TeaSet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Cup</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Cup</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Cup</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위와 같이 하면 TeaSet을 렌더링할 때마다 guest는 증가하니 우리가 원하는 것을 제대로 화면에 나타낼 수 없다. 특히나 Strict Mode를 켜놓았다면 2번 렌더링 되니 2, 4, 6으로 보일 것이다.</p>\n<p>순수성을 지키면서 올바르게 렌더링하고 싶다면 다음과 같이 guest를 Cup에게 prop으로 전달해야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Cup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> guest <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h2</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Tea cup for guest #</span><span class=\"token punctuation\">{</span>guest<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h2</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">TeaSet</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Cup</span></span> <span class=\"token attr-name\">guest</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token number\">1</span><span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Cup</span></span> <span class=\"token attr-name\">guest</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token number\">2</span><span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n      </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Cup</span></span> <span class=\"token attr-name\">guest</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span><span class=\"token number\">3</span><span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token plain-text\">\n    </span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span></span><span class=\"token punctuation\">></span></span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>앞서 Strict Mode를 언급했는데, React의 Strict Mode를 사용하면 앞서 순수성을 깨는 경우를 애초에 찾아낼 수 있다. 우리가 원하는 것은 guest가 1, 2, 3인 Cup 컴포넌트 3개를 화면에 렌더링하는 것이었다. 만약 Strict Mode가 켜져 있지 않다면 TeaSet을 호출했을 때 일단 처음엔 제대로 된 화면이 보일 것이고 우리는 무엇이 잘못 되었는지 한 번에 확인하기 어려웠을 것이다. 하지만 Strict Mode를 통해 각 컴포넌트를 2번 실행시킴으로써 1, 2, 3이 아니라 2, 4, 6이 Cup 컴포넌트에 전달될 것이다. 따라서 처음부터 잘못되었다는 것을 알아챌 수 있다.</p>\n<p>순수성을 지키기 위해 React에서는 컴포넌트가 호출되기 전에 이미 존재하는 객체 등 어떠한 변수도 변경시키면 안된다. 이러한 규칙을 부수는 경우를 빠르게 찾아내기 위해 React에서는 컴포넌트를 2번 호출하는 Strict Mode를 제공한다. root component에 <code class=\"language-text\">&lt;React.StrictMode>&lt;/React.StrictMode></code> 를 넣으면 된다. 어떤 프레임워크는 이것이 기본 설정이기도 하다.</p>\n<h2 id=\"local-mutation-your-components-little-secret\" style=\"position:relative;\"><a href=\"#local-mutation-your-components-little-secret\" aria-label=\"local mutation your components little secret permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Local mutation: Your component’s little secret</h2>\n<p>앞서 본 순수성을 깨는 예시는 렌더링 전에, 즉 컴포넌트가 호출되기 전에 이미 존재하는 변수를 변경하면서 생긴 문제를 보여줬었다. 이런 현상을 종종 돌연변이라고 부르곤 한다.</p>\n<p>하지만 컴포넌트가 호출되는 동안 컴포넌트 내부의, 즉 컴포넌트가 생성해낸 변수를 조작하는 건 완벽히 괜찮은 행동이다. 다음 예시를 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token keyword\">function</span> <span class=\"token function\">Cup</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> guest <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>h2</span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">Tea cup for guest #</span><span class=\"token punctuation\">{</span>guest<span class=\"token punctuation\">}</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>h2</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> <span class=\"token keyword\">function</span> <span class=\"token function\">TeaGathering</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> cups <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">for</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">let</span> i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;=</span> <span class=\"token number\">12</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    cups<span class=\"token punctuation\">.</span><span class=\"token function\">push</span><span class=\"token punctuation\">(</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Cup</span></span> <span class=\"token attr-name\">key</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>i<span class=\"token punctuation\">}</span></span> <span class=\"token attr-name\">guest</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>i<span class=\"token punctuation\">}</span></span> <span class=\"token punctuation\">/></span></span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">return</span> cups<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>위의 경우는 순수성을 깨지 않는다. cups는 TeaGathering이라는 컴포넌트만 사용 중이다. TeaGathering 컴포넌트는 외부의 변수를 건드리지 않는다. 따라서 자신의 관심사만 신경 쓰고 있고, 동일한 입력이 주어졌을 때 동일한 출력을 뱉어낸다. 입력값이 TeaGathering이 따로 주어지진 않았지만, TeaGathering은 계속해서 호출되더라도 1부터 12까지의 Cup 컴포넌트로 이루어진 JSX문을 계속해서 뱉어낼 것이다. 이러한 것을 local mutation이라고 하기도 한다.</p>\n<p>만약 cups라는 변수가 컴포넌트 밖에 위치해 있다면 문제가 될 것이다. TeaGathering이 호출되기 이전부터 존재하는 변수이기 때문이다. 따라서 push하는 로직은 순수성을 깨게 될 것이다.</p>\n<h2 id=\"where-you-can-cause-side-effects\" style=\"position:relative;\"><a href=\"#where-you-can-cause-side-effects\" aria-label=\"where you can cause side effects permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Where you can cause side effects</h2>\n<p>함수형 프로그래밍은 순수성에 크게 의존하고 있지만, 결국에는 어느 시점, 어느 곳에서 어떤 것을 변경시키는 사이드 이펙트가 발생해야 한다. 이는 화면을 업데이트하고 애니메이션이 시작되게 하며 데이터를 변경시키는데 이러한 현상을 사이드 이펙트라고 한다. 사이드 이펙트는 렌더링하는 동안 발생하지 않고 <code class=\"language-text\">측면에서</code> 발생한다고 공식 문서는 표현하고 있다.</p>\n<p>React에서 사이드 이펙트는 이벤트 핸들러에 속해 있다. 여기서 말하는 이벤트 핸들러는 사용자가 버튼을 클릭하는 등의 동작을 했을 때 React가 실행시키는 함수이다. <strong>이벤트 핸들러가 컴포넌트 내부에서 선언되어 있더라도 렌더링, 즉 컴포넌트가 호출되는 동안에는 실행되지 않는다. 즉 컴포넌트는 동일한 JSX문을 반환하기에 이벤트 핸들러는 순수성을 지킬 필요가 없다.</strong> React는 동일한 입력값이 주어졌을 때 동일한 JSX문을 반환한다는 순수성을 지키면 되기 때문이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"tsx\"><pre class=\"language-tsx\"><code class=\"language-tsx\"><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;</span>button</span> <span class=\"token attr-name\">onClick</span><span class=\"token script language-javascript\"><span class=\"token script-punctuation punctuation\">=</span><span class=\"token punctuation\">{</span>handleClick<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">></span></span><span class=\"token plain-text\">클릭 버튼</span><span class=\"token tag\"><span class=\"token tag\"><span class=\"token punctuation\">&lt;/</span>button</span><span class=\"token punctuation\">></span></span> <span class=\"token comment\">// handleClick이 이벤트 핸들러</span></code></pre></div>\n<p>하지만 이벤트 핸들러를 넣을 적절한 곳을 찾지 못했다면, 이벤트 핸들러를 붙여서 JSX문을 반환하는 <code class=\"language-text\">useEffect</code> 를 사용할 수 있을 것이다. 사이드 이펙트가 허용된다면 <code class=\"language-text\">useEffect</code>에 넣은 이벤트 핸들러는 렌더링 이후 동작한다. 하지만 이러한 접근은 최후의 수단이 되어야 한다고 공식 문서는 말하고 있다. → 해당 부분은 정확히, 그리고 깊게 이해하진 못했다. 나중에 Reference 부분의 Hooks에서 useEffect 챕터를 읽을 때 다시 생각해봐야겠다.</p>\n<h2 id=\"why-does-react-care-about-purity\" style=\"position:relative;\"><a href=\"#why-does-react-care-about-purity\" aria-label=\"why does react care about purity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Why does React care about purity?</h2>\n<p>순수 함수를 작성하는 것은 습관과 규칙을 필요로 한다. 즉 조금 더 신경써야 하는 부분이 생기지만 다음과 같은 좋은 점들을 맞이할 수 있다.</p>\n<ul>\n<li>컴포넌트는 서버와 같이 다른 환경에서 동작하게 될 수도 있다. 순수성을 지키고 있다면 동일한 입력값에 동일한 결과값을 반환할 것이기에 많은 사용자 요청(user request)에 응답할 수 있다. 동일한 입력값에 다른 결과값을 반환한다면 사용자는 기대한 결과를 응답으로 얻을 수 없을 것이다.</li>\n<li>입력값이 변하지 않았을 때 컴포넌트를 재호출하는 것을 생략하여 성능을 향상시킬 수 있다. 입력값이 변하지 않는다면 동일한 결과값을 가지고 있을 것이고, 이는 캐싱해두어도 안전하다는 의미이다. 즉 다시 호출해서 굳이 동일한 결과값을 확인할 필요가 없으니 입력값이 변하지 않은 컴포넌트는 호출(렌더링, rendering)을 생략해서 계산 리소스를 줄이자는 것이다.</li>\n<li>아주 깊은 컴포넌트 트리를 렌더링하던 도중에 state가 변경되어 재호출을 해야 하더라도 렌더링하던 이전의 호출을 끝마칠 필요가 없다. 즉 이전 호출을 중단하고 데이터가 변경되어 해야 하는 새로운 호출을 시작하면 된다. 이전 호출이 완전히 끝나고 나서의 데이터들을 사용하는 것이 아니기 때문이다. 순수성을 지키기에 컴포넌트 바깥의 데이터들을 신경 쓸 필요가 없다. 이전의 호출과는 무관하게 변경된 state를 바탕으로 새로운 호출을 시작하면 된다. 이전의 호출이 완전히 끝나고 나서 변경된 데이터를 사용하는 것이 아니다. → 머리로는 이해를 했는데 글로는 작성하기 어려워 여러 가지 버전의 문장으로 작성했다.\n<ul>\n<li>앞서 본 Cup, TeaSet 컴포넌트에 대한 두 가지 예시를 다시 보자. 첫 번째 예시의 경우 TeaSet 렌더링이 완전히 끝나고 나야 다음 호출이 변경된 guest를 제대로 사용할 수 있을 것이다. 두 번째 예시의 경우엔 애초에 변경할 수 있는 guest 변수가 없기도 하고, 2번 째 Cup 컴포넌트를 렌더링하던 찰나의 순간에 어떤 state가 변경되어 TeaSet이 재호출되더라도 상관이 없다. 어차피 부모에서 변한 state 혹은 prop을 바탕으로 Cup 컴포넌트들을 재렌더링하기 때문이다.</li>\n<li>이렇게 함으로써 재랜더링 되어야 할 때 이전의 렌더링을 기다릴 필요가 없으니 성능 또한 좋아질 것이라는 생각이 들었다.</li>\n</ul>\n</li>\n</ul>\n<p>React의 모든, 그리고 새로운 기능들은 이러한 순수성의 장점을 취하고 있다. 데이터 페칭부터 애니메이션과 성능까지 컴포넌트를 순수하게 유지하는 것은 리액트 패러다임을 강력하게 만들어준다.</p>\n<h2 id=\"새롭게-알게-된-점\" style=\"position:relative;\"><a href=\"#%EC%83%88%EB%A1%AD%EA%B2%8C-%EC%95%8C%EA%B2%8C-%EB%90%9C-%EC%A0%90\" aria-label=\"새롭게 알게 된 점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>새롭게 알게 된 점</h2>\n<ul>\n<li>React의 Strict Mode가 순수성을 깨는 현상을 빠르게 발견하기 위해 2번 호출하는 기능인 것을 해당 챕터를 읽으면서 알게 되었다. console로 디버깅하는 경우, 2번 호출되어 조금 번거롭다는 점 때문에 꺼놓고 개발하곤 했다. console로 디버깅하지 않을 시 되도록이면 켜놓고 하는 것이 빠르게 문제점을 찾을 수 있을 거라는 생각이 든다.</li>\n<li>아직 미약하지만 React가 어떻게 순수성을 지키고 있는지, 결국엔 발생할 수 밖에 없는 사이드 이펙트는 어떻게 다루고 있는지 조금씩이나마 체감하게 되는 것 같다.</li>\n<li>React에서의 이벤트 핸들러(Event Handler)란 무엇인지 알게 되었다. 사용자가 특정 동작(버튼 클릭 등)을 했을 때 리액트에서 실행시키는 함수이다.</li>\n<li>순수성을 지키기에 컴포넌트를 캐싱하기에 안전하다는 것을 알게 되었다.</li>\n<li>새로운 기능을 알 수 있었던 챕터는 아니지만 React가 왜 순수성을 고수하는지, 그로 인해 얻게 되는 장점이 무엇인지 알 수 있었다.</li>\n<li>순수성을 지킴으로써 이전 렌더링을 중단해도 상관이 없으니 성능 또한 향상되겠다는 생각이 들었다.</li>\n</ul>\n<h2 id=\"참고\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0\" aria-label=\"참고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고</h2>\n<p><a href=\"https://react.dev/learn/keeping-components-pure\" target=\"_blank\" rel=\"nofollow\">Keeping Components Pure</a></p>","frontmatter":{"title":"[React 공식 문서 타파하기] Keeping Components Pure","summary":"React가 고수하는 순수성이 무엇인지, 순수성을 지켰을 때 장점이 무엇인지 알아봅니다.","date":"2023-05-06","categories":["React"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABZ0lEQVR42k1RT0uXYRAcf1jsIoR6kQwJqkNCEIUShnjKUxFZHX5FFiRCfwwrOxTUqYP3oK8QfaNn9sPsbDyvr9Vh2NkHntlhBmABrFtg7YO1A9ZjtNpDq9toBbSa8RA6rIOa6Rh25sT7fvI+6RODYNMOWl0E6wtY38FaAjUFBVATD13z0LpRs8Z/4sMhZhfugsPsgtfBeg/Wb7A+oNU7tM51hFarHjlv1Btj3vXQMw9d8NBa/+yhTWeeN2rBmFse2u4OvqHVPJo+odUPtPoJ1kdQy2j1cpa65JGfjXpr1HNjHhpzz6g7xtx36rWHXhhzxUNbJw5bHaLVL7AOwHoFdj4cuOqRixbaNeqRUfeNeWDMTaPuGXM6ut415pqHbmAMvhdxBa2+gnUM1jKoJz3DM9RZC82NwS96aMlDlz00MeaqMRcs5Ma8acxzGFteB+spWA/AeohWU7TaOG3Z/oY/FnHa+ljI//wPSsAgQPycdAsAAAAASUVORK5CYII="},"images":{"fallback":{"src":"/static/4ade5cac5aba1b2a6129e12ce9a93deb/debc3/react-logo.png","srcSet":"/static/4ade5cac5aba1b2a6129e12ce9a93deb/e6d27/react-logo.png 1250w,\n/static/4ade5cac5aba1b2a6129e12ce9a93deb/f4108/react-logo.png 2500w,\n/static/4ade5cac5aba1b2a6129e12ce9a93deb/debc3/react-logo.png 5000w","sizes":"(min-width: 5000px) 5000px, 100vw"},"sources":[{"srcSet":"/static/4ade5cac5aba1b2a6129e12ce9a93deb/55a90/react-logo.webp 1250w,\n/static/4ade5cac5aba1b2a6129e12ce9a93deb/a9708/react-logo.webp 2500w,\n/static/4ade5cac5aba1b2a6129e12ce9a93deb/f1cef/react-logo.webp 5000w","type":"image/webp","sizes":"(min-width: 5000px) 5000px, 100vw"}]},"width":5000,"height":1679}},"publicURL":"/static/4ade5cac5aba1b2a6129e12ce9a93deb/react-logo.png"}}}}]}},"pageContext":{"slug":"/keeping-components-pure/","previousPost":{"title":"[React 공식 문서 타파하기] Rendering Lists","slug":"/rendering-lists/"}}},"staticQueryHashes":[],"slicesMap":{}}